// Code generated by oto; DO NOT EDIT.

package main

import (
	"context"
	"net/http"

	"github.com/opentracing/opentracing-go"
	"github.com/pacedotdev/oto/otohttp"
)

// ConferenceService is a service for managing Conferences
type ConferenceService interface {
	Get(context.Context, GetConferenceRequest) (*GetConferenceResponse, error)
	// Greet prepares a lovely greeting.
	List(context.Context, ListConferenceRequest) (*ListConferenceResponse, error)
}

type conferenceServiceServer struct {
	server            *otohttp.Server
	tracer            opentracing.Tracer
	conferenceService ConferenceService
}

// Register adds the ConferenceService to the otohttp.Server.
func RegisterConferenceService(tracer opentracing.Tracer, server *otohttp.Server, conferenceService ConferenceService) {
	handler := &conferenceServiceServer{
		server:            server,
		tracer:            tracer,
		conferenceService: conferenceService,
	}
	server.Register("ConferenceService", "Get", handler.handleGet)
	server.Register("ConferenceService", "List", handler.handleList)
}

func (s *conferenceServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request GetConferenceRequest
	var parentCtx opentracing.SpanContext
	parentSpan := opentracing.SpanFromContext(r.Context())
	if parentSpan != nil {
		parentCtx = parentSpan.Context()
	}

	// start a new Span to wrap HTTP request
	span := s.tracer.StartSpan(
		"ConferenceService.Get",
		opentracing.ChildOf(parentCtx),
	)

	// make sure the Span is finished once we're done
	defer span.Finish()

	// make the Span current in the context
	ctx := opentracing.ContextWithSpan(r.Context(), span)

	defer span.Finish()
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.Get(ctx, request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *conferenceServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	var request ListConferenceRequest
	var parentCtx opentracing.SpanContext
	parentSpan := opentracing.SpanFromContext(r.Context())
	if parentSpan != nil {
		parentCtx = parentSpan.Context()
	}

	// start a new Span to wrap HTTP request
	span := s.tracer.StartSpan(
		"ConferenceService.List",
		opentracing.ChildOf(parentCtx),
	)

	// make sure the Span is finished once we're done
	defer span.Finish()

	// make the Span current in the context
	ctx := opentracing.ContextWithSpan(r.Context(), span)

	defer span.Finish()
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.List(ctx, request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

// Conference is an event
type Conference struct {
	Name string `json:"name"`
}

// GetConferenceRequest is the request object for ConferenceService.Get.
type GetConferenceRequest struct {
}

// GetConferenceResponse is the response object containing a single Conference
type GetConferenceResponse struct {
	// Conference represents an event like GopherCon 2020
	Conference Conference `json:"conference"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// ListConferenceRequest is the request object for ConferenceService.List.
type ListConferenceRequest struct {
}

// ListConferenceResponse is the response object containing a list of Conferences
type ListConferenceResponse struct {
	// Greeting is a nice message welcoming somebody.
	Conferences []Conference `json:"conferences"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}
